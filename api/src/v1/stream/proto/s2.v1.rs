// This file is @generated by prost-build.
/// Position of a record in a stream.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StreamPosition {
    /// Sequence number assigned by the service.
    #[prost(uint64, tag = "1")]
    pub seq_num: u64,
    /// Timestamp, which may be user-specified or assigned by the service.
    /// If it is assigned by the service, it will represent milliseconds since Unix epoch.
    #[prost(uint64, tag = "2")]
    pub timestamp: u64,
}
/// Headers add structured information to a record as name-value pairs.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Header {
    /// Header name blob.
    /// The name cannot be empty, with the exception of an S2 command record.
    #[prost(bytes = "bytes", tag = "1")]
    pub name: ::prost::bytes::Bytes,
    /// Header value blob.
    #[prost(bytes = "bytes", tag = "2")]
    pub value: ::prost::bytes::Bytes,
}
/// Record to be appended to a stream.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendRecord {
    /// Timestamp for this record.
    /// Precise semantics depend on the stream's `timestamping` config.
    #[prost(uint64, optional, tag = "1")]
    pub timestamp: ::core::option::Option<u64>,
    /// Series of name-value pairs for this record.
    #[prost(message, repeated, tag = "2")]
    pub headers: ::prost::alloc::vec::Vec<Header>,
    /// Body of this record.
    #[prost(bytes = "bytes", tag = "3")]
    pub body: ::prost::bytes::Bytes,
}
/// Payload of an Append request message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendInput {
    /// Batch of records to append atomically, which must contain at least one record, and no more than 1000.
    /// The total size of a batch of records may not exceed 1MiB of metered bytes.
    #[prost(message, repeated, tag = "1")]
    pub records: ::prost::alloc::vec::Vec<AppendRecord>,
    /// Enforce that the sequence number issued to the first record matches.
    #[prost(uint64, optional, tag = "2")]
    pub match_seq_num: ::core::option::Option<u64>,
    /// Enforce a fencing token which must have been previously set by a `fence` command record.
    #[prost(string, optional, tag = "3")]
    pub fencing_token: ::core::option::Option<::prost::alloc::string::String>,
}
/// Success response message to an Append request.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AppendAck {
    /// Sequence number and timestamp of the first record that was appended.
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<StreamPosition>,
    /// Sequence number of the last record that was appended + 1, and timestamp of the last record that was appended.
    /// The difference between `end.seq_num` and `start.seq_num` will be the number of records appended.
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<StreamPosition>,
    /// Sequence number that will be assigned to the next record on the stream, and timestamp of the last record on the stream.
    /// This can be greater than the `end` position in case of concurrent appends.
    #[prost(message, optional, tag = "3")]
    pub tail: ::core::option::Option<StreamPosition>,
}
/// Record that is durably sequenced on a stream.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SequencedRecord {
    /// Sequence number assigned to this record.
    #[prost(uint64, tag = "1")]
    pub seq_num: u64,
    /// Timestamp for this record.
    #[prost(uint64, tag = "2")]
    pub timestamp: u64,
    /// Series of name-value pairs for this record.
    #[prost(message, repeated, tag = "3")]
    pub headers: ::prost::alloc::vec::Vec<Header>,
    /// Body of this record.
    #[prost(bytes = "bytes", tag = "4")]
    pub body: ::prost::bytes::Bytes,
}
/// Success response message to a Read request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadBatch {
    /// Records that are durably sequenced on the stream, retrieved based on the requested criteria.
    /// This can only be empty in response to a unary read if the request cannot be satisfied without violating an explicit bound (`count`, `bytes`, or `until`).
    /// In the context of a session, it can be empty as a heartbeat message. A heartbeat will be sent whenever a switch to following in real-time happens, and then at a randomized gap between 5 and 15 seconds if no records have become available.
    #[prost(message, repeated, tag = "1")]
    pub records: ::prost::alloc::vec::Vec<SequencedRecord>,
    /// Sequence number that will be assigned to the next record on the stream, and timestamp of the last record.
    /// It will only be present when reading recent records.
    #[prost(message, optional, tag = "2")]
    pub tail: ::core::option::Option<StreamPosition>,
}

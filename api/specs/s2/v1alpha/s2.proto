syntax = "proto3";

package s2.v1alpha;

import "google/protobuf/field_mask.proto";

option java_multiple_files = true;
option java_package = "s2.v1alpha";

// Operate on an S2 account.
service AccountService {
  // List basins.
  rpc ListBasins(ListBasinsRequest) returns (ListBasinsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Create a new basin.
  // Provide a client request token with the `S2-Request-Token` header for idempotent retry behaviour.
  rpc CreateBasin(CreateBasinRequest) returns (CreateBasinResponse) {
    option idempotency_level = IDEMPOTENT;
  }

  // Delete a basin.
  // Basin deletion is asynchronous, and may take a few minutes to complete.
  rpc DeleteBasin(DeleteBasinRequest) returns (DeleteBasinResponse) {
    option idempotency_level = IDEMPOTENT;
  }

  // Update basin configuration.
  rpc ReconfigureBasin(ReconfigureBasinRequest) returns (ReconfigureBasinResponse) {
    option idempotency_level = IDEMPOTENT;
  }

  // Get basin configuration.
  rpc GetBasinConfig(GetBasinConfigRequest) returns (GetBasinConfigResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Issue a new access token.
  rpc IssueAccessToken(IssueAccessTokenRequest) returns (IssueAccessTokenResponse);

  // Revoke an access token.
  rpc RevokeAccessToken(RevokeAccessTokenRequest) returns (RevokeAccessTokenResponse) {
    option idempotency_level = IDEMPOTENT;
  }

  // List access tokens.
  rpc ListAccessTokens(ListAccessTokensRequest) returns (ListAccessTokensResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
}

// Operate on an S2 basin.
service BasinService {
  // List streams.
  rpc ListStreams(ListStreamsRequest) returns (ListStreamsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Create a stream.
  // Provide a client request token with the `S2-Request-Token` header for idempotent retry behaviour.
  rpc CreateStream(CreateStreamRequest) returns (CreateStreamResponse) {
    option idempotency_level = IDEMPOTENT;
  }

  // Delete a stream.
  // Stream deletion is asynchronous, and may take a few minutes to complete.
  rpc DeleteStream(DeleteStreamRequest) returns (DeleteStreamResponse) {
    option idempotency_level = IDEMPOTENT;
  }

  // Get stream configuration.
  rpc GetStreamConfig(GetStreamConfigRequest) returns (GetStreamConfigResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Update stream configuration.
  rpc ReconfigureStream(ReconfigureStreamRequest) returns (ReconfigureStreamResponse) {
    option idempotency_level = IDEMPOTENT;
  }
}

// Operate on an S2 stream.
service StreamService {
  // Check the tail of the stream.
  rpc CheckTail(CheckTailRequest) returns (CheckTailResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Append a batch of records to a stream.
  rpc Append(AppendRequest) returns (AppendResponse);

  // Append batches of records to a stream continuously, while guaranteeing pipelined requests are processed in order.
  // If any request fails, the session is terminated.
  rpc AppendSession(stream AppendSessionRequest) returns (stream AppendSessionResponse);

  // Retrieve a batch of records from a stream.
  rpc Read(ReadRequest) returns (ReadResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Retrieve batches of records from a stream continuously.
  rpc ReadSession(ReadSessionRequest) returns (stream ReadSessionResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
}

/// AccountService ///

// List basins request.
message ListBasinsRequest {
  // List basin names that begin with this prefix.
  string prefix = 1;
  // Only return basins names that lexicographically start after this name.
  // This can be the last basin name seen in a previous listing, to continue from there.
  // It must be greater than or equal to the prefix if specified.
  string start_after = 2;
  // Number of results, up to a maximum of 1000.
  optional uint64 limit = 3;
}

// List basins response.
message ListBasinsResponse {
  // Matching basins.
  repeated BasinInfo basins = 1;
  // If set, indicates there are more results that can be listed with `start_after`.
  bool has_more = 2;
}

// Create basin request.
message CreateBasinRequest {
  // Basin name, which must be globally unique.
  // The name must be between 8 and 48 characters, comprising lowercase letters, numbers and hyphens.
  // It cannot begin or end with a hyphen.
  string basin = 1;
  // Basin configuration.
  BasinConfig config = 2;
  // Basin scope.
  BasinScope scope = 3;
}

// Basin scope.
enum BasinScope {
  // Unspecified basin scope.
  BASIN_SCOPE_UNSPECIFIED = 0;
  // aws us-east-1 region.
  BASIN_SCOPE_AWS_US_EAST_1 = 1;
}

// Create basin response.
message CreateBasinResponse {
  // Information about the newly created basin.
  BasinInfo info = 1;
}

// Delete basin request.
message DeleteBasinRequest {
  // Name of the basin to delete.
  string basin = 1;
}

// Delete basin response.
message DeleteBasinResponse {}

// Get basin configuration request.
message GetBasinConfigRequest {
  // Basin name.
  string basin = 1;
}

// Get basin configuration response.
message GetBasinConfigResponse {
  // Basin configuration.
  BasinConfig config = 1;
}

// Reconfigure basin request.
message ReconfigureBasinRequest {
  // Basin name.
  string basin = 1;
  // Basin configuration.
  BasinConfig config = 2;
  // Specifies the pieces of configuration being updated.
  // See https://protobuf.dev/reference/protobuf/google.protobuf/#field-mask
  google.protobuf.FieldMask mask = 3;
}

// Reconfigure basin response.
message ReconfigureBasinResponse {
  // Basin configuration.
  BasinConfig config = 1;
}

// Issue access token request.
message IssueAccessTokenRequest {
  // Access token information.
  AccessTokenInfo info = 1;
}

// API operations.
enum Operation {
  // Unspecified operation.
  OPERATION_UNSPECIFIED = 0;
  // List basins.
  OPERATION_LIST_BASINS = 1;
  // Create a basin.
  OPERATION_CREATE_BASIN = 2;
  // Delete a basin.
  OPERATION_DELETE_BASIN = 3;
  // Update basin configuration.
  OPERATION_RECONFIGURE_BASIN = 4;
  // Get basin configuration.
  OPERATION_GET_BASIN_CONFIG = 5;
  // Issue an access token.
  OPERATION_ISSUE_ACCESS_TOKEN = 6;
  // Revoke an access token.
  OPERATION_REVOKE_ACCESS_TOKEN = 7;
  // List access tokens.
  OPERATION_LIST_ACCESS_TOKENS = 8;
  // List streams.
  OPERATION_LIST_STREAMS = 9;
  // Create a stream.
  OPERATION_CREATE_STREAM = 10;
  // Delete a stream.
  OPERATION_DELETE_STREAM = 11;
  // Get stream configuration.
  OPERATION_GET_STREAM_CONFIG = 12;
  // Update stream configuration.
  OPERATION_RECONFIGURE_STREAM = 13;
  // Check tail of a stream.
  OPERATION_CHECK_TAIL = 14;
  // Append records to a stream.
  OPERATION_APPEND = 15;
  // Read records from a stream.
  OPERATION_READ = 16;
  // Trim records up to a sequence number.
  OPERATION_TRIM = 17;
  // Set a fencing token for a stream.
  OPERATION_FENCE = 18;
  // Retrieve account-level metrics.
  OPERATION_ACCOUNT_METRICS = 19;
  // Retrieve basin-level metrics.
  OPERATION_BASIN_METRICS = 20;
  // Retrieve stream-level metrics.
  OPERATION_STREAM_METRICS = 21;
}

// Read/Write permissions.
message ReadWritePermissions {
  // Read permission.
  bool read = 1;
  // Write permission.
  bool write = 2;
}

// Access permissions for a group.
message PermittedOperationGroups {
  // Access permissions at account level.
  ReadWritePermissions account = 1;
  // Access permissions at basin level.
  ReadWritePermissions basin = 2;
  // Access permissions at stream level.
  ReadWritePermissions stream = 3;
}

// Revoke access token request.
message RevokeAccessTokenRequest {
  // Token to revoke.
  string id = 1;
}

// Revoke access token response.
message RevokeAccessTokenResponse {
  // Access token information.
  AccessTokenInfo info = 1;
}

// List access tokens request.
message ListAccessTokensRequest {
  // List access tokens that begin with this prefix.
  string prefix = 1;
  // Only return access tokens that lexicographically start after this ID.
  string start_after = 2;
  // Number of results, up to a maximum of 1000.
  optional uint64 limit = 3;
}

// List access tokens response.
message ListAccessTokensResponse {
  // Access tokens information.
  repeated AccessTokenInfo access_tokens = 1;
  // If set, indicates there are more results that can be listed with `start_after`.
  bool has_more = 2;
}

// Access token information.
message AccessTokenInfo {
  // Access token ID.
  // It must be unique to the account and between 1 and 96 characters.
  string id = 1;
  // Expiration time in seconds since Unix epoch.
  // If not set, the expiration will be set to that of the requestor's token.
  optional uint32 expires_at = 2;
  // Namespace streams based on the configured stream-level scope, which must be a prefix.
  // Stream name arguments will be automatically prefixed, and the prefix will be stripped
  // when listing streams.
  bool auto_prefix_streams = 3;
  // Access token scope.
  AccessTokenScope scope = 4;
}

// Access token scope.
message AccessTokenScope {
  // Basin names allowed.
  ResourceSet basins = 1;
  // Stream names allowed.
  ResourceSet streams = 2;
  // Token IDs allowed.
  ResourceSet access_tokens = 3;
  // Access permissions at operation group level.
  PermittedOperationGroups op_groups = 4;
  // Operations allowed for the token.
  // A union of allowed operations and groups is used as an effective set of allowed operations.
  repeated Operation ops = 5;
}

// Set of named resources.
message ResourceSet {
  // Matching rule.
  oneof matching {
    // Match only the resource with this exact name.
    // Use an empty string to match no resources.
    string exact = 1;
    // Match all resources that start with this prefix.
    // Use an empty string to match all resource.
    string prefix = 2;
  }
}

// Issue access token response.
message IssueAccessTokenResponse {
  // Created access token.
  string access_token = 1;
}

/// BasinService ///

// Stream information.
message StreamInfo {
  // Stream name.
  string name = 1;
  // Creation time in seconds since Unix epoch.
  uint32 created_at = 2;
  // Deletion time in seconds since Unix epoch, if the stream is being deleted.
  optional uint32 deleted_at = 3;
}

// List streams request.
message ListStreamsRequest {
  // List stream names that begin with this prefix.
  string prefix = 1;
  // Only return stream names that lexicographically start after this name.
  // This can be the last stream name seen in a previous listing, to continue from there.
  // It must be greater than or equal to the prefix if specified.
  string start_after = 2;
  // Number of results, up to a maximum of 1000.
  optional uint64 limit = 3;
}

// List streams response.
message ListStreamsResponse {
  // Matching streams.
  repeated StreamInfo streams = 1;
  // If set, indicates there are more results that can be listed with `start_after`.
  bool has_more = 2;
}

// Create stream request.
message CreateStreamRequest {
  // Stream name, which must be unique within the basin.
  // It can be an arbitrary string upto 512 characters.
  // Backslash (`/`) is recommended as a delimiter for hierarchical naming.
  string stream = 1;
  // Configuration for the new stream.
  StreamConfig config = 2;
}

// Create stream response.
message CreateStreamResponse {
  // Information about the newly created stream.
  StreamInfo info = 1;
}

// Delete stream request.
message DeleteStreamRequest {
  // Stream name.
  string stream = 1;
}

// Delete stream response.
message DeleteStreamResponse {}

// Get stream configuration request.
message GetStreamConfigRequest {
  // Stream name.
  string stream = 1;
}

// Get stream configuration response.
message GetStreamConfigResponse {
  // Stream configuration.
  StreamConfig config = 1;
}

// Reconfigure stream request.
message ReconfigureStreamRequest {
  // Stream name.
  string stream = 1;
  // Stream configuration with updated values.
  StreamConfig config = 2;
  // Specifies the pieces of configuration being updated.
  // See https://protobuf.dev/reference/protobuf/google.protobuf/#field-mask
  google.protobuf.FieldMask mask = 3;
}

// Reconfigure stream response.
message ReconfigureStreamResponse {
  // Stream configuration.
  StreamConfig config = 1;
}

/// StreamService ///

// Check tail request.
message CheckTailRequest {
  // Stream name.
  string stream = 1;
}

// Check tail response.
message CheckTailResponse {
  // Sequence number that will be assigned to the next record on the stream.
  // It will be 0 for a stream that has not been written to.
  uint64 next_seq_num = 1;
  // Timestamp of the last durable record on the stream.
  // It starts out as 0 for a new stream.
  uint64 last_timestamp = 2;
}

// Input for append requests.
message AppendInput {
  // Stream name. Optional for subsequent requests in the session.
  string stream = 1;
  // Batch of records to append atomically, which must contain at least one record, and no more than 1000.
  // The total size of a batch of records may not exceed 1MiB of metered bytes.
  repeated AppendRecord records = 2;
  // Enforce that the sequence number issued to the first record matches.
  optional uint64 match_seq_num = 3;
  // Enforce a fencing token which must have been previously set by a `fence` command record.
  optional string fencing_token = 4;
}

// Output from append response.
message AppendOutput {
  // Sequence number of first record appended.
  uint64 start_seq_num = 1;
  // Timestamp of the first record appended.
  uint64 start_timestamp = 4;
  // Sequence number of last record appended + 1.
  // `end_seq_num - start_seq_num` will be the number of records in the batch.
  uint64 end_seq_num = 2;
  // Timestamp of the last record appended.
  uint64 end_timestamp = 5;
  // Tail of the stream, i.e. sequence number that will be assigned to the next record.
  // This can be greater than `end_seq_num` in case of concurrent appends.
  uint64 next_seq_num = 3;
  // Timestamp of the last durable record on the stream.
  uint64 last_timestamp = 6;
}

// Append request.
message AppendRequest {
  // Request parameters for an append.
  AppendInput input = 1;
}

// Append response.
message AppendResponse {
  // Response details for an append.
  AppendOutput output = 1;
}

// Append session request.
message AppendSessionRequest {
  // Request parameters for an append.
  AppendInput input = 1;
}

// Append session response.
message AppendSessionResponse {
  // Response details for an append.
  AppendOutput output = 1;
}

// Output of a read.
message ReadOutput {
  // Batch of records or the next sequence number on the stream.
  oneof output {
    // Batch of records.
    // It can only be empty when not in a session context,
    // if the request cannot be satisfied without violating its limit.
    SequencedRecordBatch batch = 1;
    // Tail of the stream, i.e. sequence number that will be assigned to the next record.
    // It will be returned if the requested starting position is greater than the tail,
    // or only in case of a limited read, equal to it.
    // It will also be returned if there are no records on the stream between the
    // requested starting position and the tail.
    uint64 next_seq_num = 3;
  }
  // first_seq_num.
  reserved 2;
}

// Read request.
message ReadRequest {
  // Stream name.
  string stream = 1;
  // Starting position for records.
  // Retrieved batches will start at the first record whose position is greater than or equal to it.
  oneof start {
    // Sequence number.
    uint64 seq_num = 2;
    // Timestamp.
    uint64 timestamp = 4;
    // Number of records before the tail, i.e. before the next sequence number.
    uint64 tail_offset = 5;
  }
  // Limit how many records can be returned.
  // This will get capped at the default limit,
  // which is up to 1000 records or 1MiB of metered bytes.
  ReadLimit limit = 3;
  // Exclusive timestamp to read until.
  // If provided, this is applied as an additional constraint on top of the `limit`,
  // and will guarantee that all records returned have timestamps < the provided `until`.
  optional uint64 until = 6;
  // Start reading from the tail if the requested position is beyond it.
  // Otherwise, the next sequence number will be returned.
  bool clamp = 7;
}

// Read response.
message ReadResponse {
  // Response details for a read.
  ReadOutput output = 1;
}

// Limit how many records can be retrieved.
// If both count and bytes are specified, either limit may be hit.
message ReadLimit {
  // Record count limit.
  optional uint64 count = 1;
  // Metered bytes limit.
  optional uint64 bytes = 2;
}

// Read session request.
message ReadSessionRequest {
  // Stream name.
  string stream = 1;
  // Starting position for records.
  // Retrieved batches will start at the first record whose position is greater than or equal to it.
  oneof start {
    // Sequence number.
    uint64 seq_num = 2;
    // Timestamp.
    uint64 timestamp = 5;
    // Number of records before the tail, i.e. the next sequence number.
    uint64 tail_offset = 6;
  }
  // Limit on how many records can be returned. When a limit is specified, the session will be terminated as soon as
  // the limit is met, or when the current tail of the stream is reached -- whichever occurs first.
  // If no limit is specified, the session will remain open after catching up to the tail, and continue following
  // in real-time as new messages are written to the stream.
  ReadLimit limit = 3;
  // Heartbeats can be enabled to monitor end-to-end session health.
  // A heartbeat will be sent when the initial switch to following in real-time happens,
  // as well as when no records are available at a randomized interval between 5 and 15 seconds.
  bool heartbeats = 4;
  // Exclusive timestamp to read until.
  // If provided, this is applied as an additional constraint on top of the `limit`,
  // and will guarantee that all records returned have timestamps < the provided `until`.
  optional uint64 until = 7;
  // Start reading from the tail if the requested position is beyond it.
  // Otherwise, the next sequence number will be returned.
  bool clamp = 8;
}

// Read session response.
message ReadSessionResponse {
  // Response details for a read.
  // This will not be set in case of a heartbeat message.
  optional ReadOutput output = 1;
}

/// Common types ///

// Storage class for recent writes.
enum StorageClass {
  // Defaults to `STORAGE_CLASS_EXPRESS`.
  STORAGE_CLASS_UNSPECIFIED = 0;
  // Standard, which offers end-to-end latencies under 500 ms.
  STORAGE_CLASS_STANDARD = 1;
  // Express, which offers end-to-end latencies under 50 ms.
  STORAGE_CLASS_EXPRESS = 2;
}

// Timestamping mode.
// Note that arrival time is always in milliseconds since Unix epoch.
enum TimestampingMode {
  // Defaults to `TIMESTAMPING_MODE_CLIENT_PREFER`.
  TIMESTAMPING_MODE_UNSPECIFIED = 0;
  // Prefer client-specified timestamp if present otherwise use arrival time.
  TIMESTAMPING_MODE_CLIENT_PREFER = 1;
  // Require a client-specified timestamp and reject the append if it is missing.
  TIMESTAMPING_MODE_CLIENT_REQUIRE = 2;
  // Use the arrival time and ignore any client-specified timestamp.
  TIMESTAMPING_MODE_ARRIVAL = 3;
}

// Stream configuration.
message StreamConfig {
  message Timestamping {
    // Timestamping mode for appends that influences how timestamps are handled.
    TimestampingMode mode = 1;
    // Allow client-specified timestamps to exceed the arrival time.
    // If this is false or not set, client timestamps will be capped at the arrival time.
    optional bool uncapped = 2;
  }
  message DeleteOnEmpty {
    // Minimum age in seconds before an empty stream can be deleted.
    // Set to 0 (default) to disable (don't delete automatically).
    uint64 min_age_secs = 1;
  }
  message InfiniteRetention {}
  // Storage class for recent writes.
  StorageClass storage_class = 1;
  // Retention policy for the stream.
  // If unspecified, the default is to retain records for 7 days.
  oneof retention_policy {
    // Age in seconds for automatic trimming of records older than this threshold.
    // This must be set to a value greater than 0 seconds.
    uint64 age = 2;
    // Retain records unless explicitly trimmed.
    InfiniteRetention infinite = 7;
  }
  // Replaced with `timestamping`.
  reserved 3, 4;
  // Timestamping behavior.
  Timestamping timestamping = 5;
  // Delete-on-empty configuration.
  DeleteOnEmpty delete_on_empty = 6;
}

// Basin configuration.
message BasinConfig {
  // Default stream configuration.
  StreamConfig default_stream_config = 1;
  // Create stream on append if it doesn't exist,
  // using the default stream configuration.
  bool create_stream_on_append = 2;
  // Create stream on read if it doesn't exist,
  // using the default stream configuration.
  bool create_stream_on_read = 3;
}

// Current state of the basin.
enum BasinState {
  // Unspecified.
  BASIN_STATE_UNSPECIFIED = 0;
  // Basin is active.
  BASIN_STATE_ACTIVE = 1;
  // Basin is being created.
  BASIN_STATE_CREATING = 2;
  // Basin is being deleted.
  BASIN_STATE_DELETING = 3;
}

// Basin information.
message BasinInfo {
  // Basin name.
  string name = 1;
  // Basin scope.
  BasinScope scope = 5;
  // Basin state.
  BasinState state = 4;
}

// Headers add structured information to a record as name-value pairs.
message Header {
  // Header name blob.
  // The name cannot be empty, with the exception of an S2 command record.
  bytes name = 1;
  // Header value blob.
  bytes value = 2;
}

// Record to be appended to a stream.
message AppendRecord {
  // Timestamp for this record.
  // Precise semantics depend on the stream's `timestamping` config.
  optional uint64 timestamp = 3;
  // Series of name-value pairs for this record.
  repeated Header headers = 1;
  // Body of this record.
  bytes body = 2;
}

// Record retrieved from a stream.
message SequencedRecord {
  // Sequence number assigned to this record.
  uint64 seq_num = 1;
  // Timestamp for this record.
  uint64 timestamp = 4;
  // Series of name-value pairs for this record.
  repeated Header headers = 2;
  // Body of this record.
  bytes body = 3;
}

// A batch of sequenced records.
message SequencedRecordBatch {
  // Batch of sequenced records.
  repeated SequencedRecord records = 1;
}
